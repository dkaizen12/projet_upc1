Parfait ğŸ‘Œ, maintenant que tu as mis en place lâ€™**authentification Firebase (email + Google)** dans tes pages personnalisÃ©es, voici comment aller plus loin avec les deux points suivants :

## âœ… 1. ğŸ”„ **Synchroniser Firestore dans `ProfilWidget`**

Pour afficher les vraies infos utilisateur (nom, email, photo, statsâ€¦) dans ton `ProfilWidget`, tu dois :

### a. ğŸ” RÃ©cupÃ©rer lâ€™ID utilisateur courant :

```dart
final currentUser = FirebaseAuth.instance.currentUser;
```

### b. ğŸ”¥ RÃ©cupÃ©rer les donnÃ©es Firestore associÃ©es Ã  cet utilisateur :

CrÃ©e une mÃ©thode dans `AuthService` ou dans un autre fichier comme `user_service.dart` :

```dart
Future<UserModel?> getCurrentUserData() async {
  final user = FirebaseAuth.instance.currentUser;
  if (user == null) return null;

  final doc = await FirebaseFirestore.instance.collection('users').doc(user.uid).get();
  if (!doc.exists) return null;

  return UserModel.fromMap(doc.data()!);
}
```

### c. ğŸ“¦ Dans `ProfilWidget` :

```dart
class ProfilWidget extends StatefulWidget {
  const ProfilWidget({super.key});

  @override
  State<ProfilWidget> createState() => _ProfilWidgetState();
}

class _ProfilWidgetState extends State<ProfilWidget> {
  UserModel? userModel;

  @override
  void initState() {
    super.initState();
    _loadUserData();
  }

  Future<void> _loadUserData() async {
    final data = await AuthService().getCurrentUserData();
    setState(() {
      userModel = data;
    });
  }

  @override
  Widget build(BuildContext context) {
    if (userModel == null) {
      return const Center(child: CircularProgressIndicator());
    }

    return Column(
      children: [
        CircleAvatar(
          radius: 40,
          backgroundImage: userModel!.photoUrl != null
              ? NetworkImage(userModel!.photoUrl!)
              : const AssetImage('assets/default_avatar.png') as ImageProvider,
        ),
        Text(userModel!.nom, style: const TextStyle(fontSize: 20)),
        Text(userModel!.email),
        Text("AbonnÃ©s : ${userModel!.abonnes}"),
        Text("Abonnements : ${userModel!.abonnements}"),
        Text("Likes : ${userModel!.likes}"),
      ],
    );
  }
}
```

## âœ… 2. ğŸ” GÃ©rer la session utilisateur (`FirebaseAuth.instance.currentUser`)

Firebase gÃ¨re **automatiquement la session** de l'utilisateur :

* Une fois connectÃ©, `FirebaseAuth.instance.currentUser` **reste disponible** Ã  travers les redÃ©marrages de lâ€™app (persistant).
* Tu peux donc lâ€™utiliser Ã  tout moment dans lâ€™app pour :

  * vÃ©rifier si lâ€™utilisateur est connectÃ©
  * rÃ©cupÃ©rer son UID, email, nom, photo...

### Exemple :

```dart
final user = FirebaseAuth.instance.currentUser;

if (user != null) {
  print("Utilisateur connectÃ© : ${user.email}");
} else {
  print("Aucun utilisateur connectÃ©");
}
```

### â• Tu peux mÃªme faire une redirection conditionnelle au dÃ©marrage :

```dart
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp();

  final user = FirebaseAuth.instance.currentUser;

  runApp(MaterialApp(
    home: user != null ? const HomePage() : const LoginView(),
  ));
}
```

---

## ğŸ“Œ Tu veux aller plus loin ?

Souhaites-tu que je tâ€™aide Ã  intÃ©grer :

* ğŸ” La **mise Ã  jour** du profil utilisateur ?
* ğŸ§­ Un **middleware `AuthGate`** pour empÃªcher lâ€™accÃ¨s aux pages non connectÃ©es ?
* ğŸ§¼ Un **bouton de dÃ©connexion** global ?
* ğŸ’¾ Un cache local du `UserModel` avec `SharedPreferences` ou `Provider` ?
* ğŸ“¸ Un systÃ¨me dâ€™upload de photo de profil ?

Dis-moi ce que tu veux prioriser et je te le code directement adaptÃ© Ã  ton app `Stories_kin`.

Parfait âœ… ! Voici donc ce qu'on va faire maintenant :

---

## âœ… 1. ğŸ” **DÃ©connexion avec le bouton que tu as dÃ©jÃ **

Si tu as dÃ©jÃ  placÃ© un `ElevatedButton` ou un `ListTile` pour la dÃ©connexion, il te suffit dâ€™y ajouter :

```dart
onPressed: () async {
  await AuthService().logout();
  // Optionnel : Efface aussi le cache local si on utilise SharedPreferences
  final prefs = await SharedPreferences.getInstance();
  await prefs.remove('user_model');

  // Redirige vers la page de login
  Navigator.pushReplacementNamed(context, '/login');
},
```

Assure-toi que `AuthService().logout()` contient bien :

```dart
Future<void> logout() async {
  await FirebaseAuth.instance.signOut();
  await GoogleSignIn().signOut();
}
```

---

## âœ… 2. ğŸ’¾ **Stocker localement le `UserModel`**

On va faire un **double systÃ¨me** :

### ğŸ”¹ A. Avec `SharedPreferences` pour persister les donnÃ©es localement (mÃªme aprÃ¨s redÃ©marrage)
### ğŸ”¹ B. Avec `Provider` pour accÃ©der rapidement aux infos dans toute lâ€™app (gestion dâ€™Ã©tat)

---

### ğŸ”§ Ã‰tape 1 : Ajouter les packages

Dans `pubspec.yaml` :

```yaml
dependencies:
  provider: ^6.1.1
  shared_preferences: ^2.2.2
```

---

### ğŸ”§ Ã‰tape 2 : CrÃ©er un `UserProvider`

```dart
import 'package:flutter/material.dart';
import '../model_data/user.dart';

class UserProvider with ChangeNotifier {
  UserModel? _user;

  UserModel? get user => _user;

  void setUser(UserModel user) {
    _user = user;
    notifyListeners();
  }

  void clearUser() {
    _user = null;
    notifyListeners();
  }
}
```

---

### ğŸ”§ Ã‰tape 3 : Stocker / lire le `UserModel` dans `SharedPreferences`

#### â• Ajoute dans `auth_service.dart` :

```dart
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';

Future<void> saveUserToLocal(UserModel user) async {
  final prefs = await SharedPreferences.getInstance();
  final userJson = jsonEncode(user.toMap());
  await prefs.setString('user_model', userJson);
}

Future<UserModel?> loadUserFromLocal() async {
  final prefs = await SharedPreferences.getInstance();
  final userJson = prefs.getString('user_model');
  if (userJson == null) return null;

  final data = jsonDecode(userJson);
  return UserModel.fromMap(data);
}
```

---

### ğŸ”§ Ã‰tape 4 : Modifier la connexion pour sauvegarder localement

Dans `loginView` ou `registre_page`, aprÃ¨s un login/register rÃ©ussi :

```dart
final userData = await AuthService().getCurrentUserData();

if (userData != null) {
  await saveUserToLocal(userData);
  Provider.of<UserProvider>(context, listen: false).setUser(userData);
  Navigator.pushReplacementNamed(context, '/home');
}
```

---

### ğŸ”§ Ã‰tape 5 : Initialiser `UserProvider` avec les donnÃ©es locales (au dÃ©marrage)

Dans `main.dart` :

```dart
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp();

  final savedUser = await loadUserFromLocal();

  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => UserProvider()),
      ],
      child: MyApp(initialUser: savedUser),
    ),
  );
}
```

Et dans `MyApp` :

```dart
class MyApp extends StatelessWidget {
  final UserModel? initialUser;

  const MyApp({super.key, this.initialUser});

  @override
  Widget build(BuildContext context) {
    if (initialUser != null) {
      Provider.of<UserProvider>(context, listen: false).setUser(initialUser!);
    }

    return MaterialApp(
      home: FirebaseAuth.instance.currentUser != null
          ? const HomePage()
          : const LoginView(),
    );
  }
}
```

---

## ğŸ§ª RÃ©sultat :

âœ… Tu as maintenant :

* Un systÃ¨me de **dÃ©connexion complet** (Firebase + Google + nettoyage local)
* Un systÃ¨me **persistant** avec `SharedPreferences`
* Un **Provider rÃ©actif** pour accÃ©der rapidement au `UserModel` dans nâ€™importe quel widget

---

Souhaites-tu que je te montre :

* ğŸ” Comment mettre Ã  jour le `UserModel` et re-synchroniser le cache ?
* ğŸ“¸ Ou bien passer Ã  lâ€™upload de photo de profil via `Firebase Storage` + image\_picker ?
